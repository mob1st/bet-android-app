package br.com.mob1st.features.finances.impl.infra.data.repositories.categories

import br.com.mob1st.core.kotlinx.structures.Money
import br.com.mob1st.core.kotlinx.structures.RowId
import br.com.mob1st.features.finances.impl.Category_view
import br.com.mob1st.features.finances.impl.domain.entities.Category
import br.com.mob1st.features.finances.impl.domain.entities.Recurrences
import br.com.mob1st.features.finances.impl.domain.values.DayAndMonth
import br.com.mob1st.features.finances.impl.domain.values.DayOfMonth
import br.com.mob1st.features.finances.impl.domain.values.Month

/**
 * Maps a list of [Category_view], a class generated by sqldelight to a list of [Category] domain entity.
 */
object SelectCategoryViewsMapper {
    /**
     * Group the list of [Category_view] by the category id and map it to a list of [Category] domain entity.
     * This method depend on a contract where the relation between the category and the recurrences tables are
     * respected.
     * It assumes that:
     * - A category and a fixed recurrences have a one-to-one relation.
     * - A category and the seasonal recurrences have a one-to-many relation.
     * - If no recurrences are found, it assumes that the category has a variable recurrence.
     * It also takes in consideration that a category cannot be related to two different types of recurrences in the
     * database.
     * @param query The list of [Category_view] to be mapped.
     * @return The list of [Category] domain entities.
     * @throws IllegalStateException if a category has no reference in the recurrence table.
     */
    fun map(query: List<Category_view>): List<Category> {
        return query.groupBy { it.cat_id }.map { entry ->
            entry.toDomain()
        }
    }
}

private fun Map.Entry<Long, List<Category_view>>.toDomain(): Category {
    val categoryProjection = value.first()
    return Category(
        id = RowId(categoryProjection.cat_id),
        name = categoryProjection.cat_name,
        amount = Money(categoryProjection.cat_amount),
        isExpense = categoryProjection.cat_is_expense,
        recurrences = value.toRecurrences(),
    )
}

private fun List<Category_view>.toRecurrences(): Recurrences {
    val first = first()
    return when {
        first.frc_day_of_month != null -> first.toFixedRecurrence()
        first.src_month != null && first().src_day != null -> toSeasonalRecurrences()
        else -> Recurrences.Variable
    }
}

private fun Category_view.toFixedRecurrence(): Recurrences.Fixed {
    val daysOfMonth = DayOfMonth(frc_day_of_month!!)
    return Recurrences.Fixed(daysOfMonth)
}

private fun List<Category_view>.toSeasonalRecurrences(): Recurrences.Seasonal {
    val daysAndMonths = map { projection ->
        DayAndMonth(
            day = DayOfMonth(projection.src_day!!),
            month = Month(projection.src_month!!),
        )
    }
    return Recurrences.Seasonal(daysAndMonths)
}
