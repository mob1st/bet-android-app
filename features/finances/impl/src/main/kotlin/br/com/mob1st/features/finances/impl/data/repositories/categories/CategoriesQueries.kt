package br.com.mob1st.features.finances.impl.data.repositories.categories

import app.cash.sqldelight.TransactionCallbacks
import app.cash.sqldelight.coroutines.asFlow
import app.cash.sqldelight.coroutines.mapToList
import br.com.mob1st.core.kotlinx.structures.RowId
import br.com.mob1st.features.finances.impl.CategoriesQueries
import br.com.mob1st.features.finances.impl.Category_view
import br.com.mob1st.features.finances.impl.domain.entities.Category
import br.com.mob1st.features.finances.impl.domain.entities.CategorySuggestion
import br.com.mob1st.features.finances.impl.domain.entities.Recurrences
import kotlinx.coroutines.flow.Flow
import kotlin.coroutines.CoroutineContext

/**
 * Maps a list of [Category_view], a class generated by sqldelight to a list of [Category] domain entity.
 * @param context The coroutine context to map the query result to a list of [Category].
 * @param isExpense Whether the categories are expenses or incomes.
 * @return The list of [Category] domain entities.
 */
internal fun CategoriesQueries.selectManuallyCreatedCategories(
    context: CoroutineContext,
    isExpense: Boolean,
): Flow<List<Category_view>> {
    return selectManuallyCreatedCategories(isExpense)
        .asFlow()
        .mapToList(context)
}

/**
 * Inserts a new category.
 * This method needs to be called inside a transaction because a category should be inserted with its recurrences.
 * @param category The category to be added.
 * @param linkedSuggestion The suggestion that was linked to the category, if any.
 * @see CategoriesQueries.insertRecurrences to check how the recurrences are inserted.
 */
context(TransactionCallbacks)
internal fun CategoriesQueries.insertCategories(
    category: Category,
    linkedSuggestion: CategorySuggestion?,
) {
    insertCategory(
        name = category.name,
        amount = category.amount.cents,
        linked_suggestion_id = linkedSuggestion?.id?.value,
        is_expense = category.isExpense,
    )
}

/**
 * Inserts the recurrences of a category.
 * This method have to be called inside a transaction because the recurrences should be inserted only if a category is
 * already inserted.
 * @param id The id of the category that the recurrences are related to.
 * @param recurrences The recurrences to be inserted.
 * @see CategoriesQueries.insertCategories to check how the category is inserted.
 */
context(TransactionCallbacks)
internal fun CategoriesQueries.insertRecurrences(
    id: RowId,
    recurrences: Recurrences,
) {
    when (recurrences) {
        is Recurrences.Fixed -> insertFixedRecurrence(id, recurrences)
        is Recurrences.Variable -> insertVariableRecurrence(id, recurrences)
        is Recurrences.Seasonal -> insertSeasonalRecurrence(id, recurrences)
    }
}

private fun CategoriesQueries.insertFixedRecurrence(
    id: RowId,
    recurrences: Recurrences.Fixed,
) {
    recurrences.daysOfMonth.forEach { day ->
        insertFixedRecurrence(
            id = id.value,
            day_of_month = day.value,
        )
    }
}

private fun CategoriesQueries.insertVariableRecurrence(
    id: RowId,
    recurrences: Recurrences.Variable,
) {
    recurrences.daysOfWeek.forEach { day ->
        insertVariableRecurrence(
            id = id.value,
            day_of_week = day.value,
        )
    }
}

private fun CategoriesQueries.insertSeasonalRecurrence(
    id: RowId,
    recurrences: Recurrences.Seasonal,
) {
    recurrences.daysAndMonths.forEach { (day, month) ->
        insertSeasonalRecurrence(
            id = id.value,
            day = day.value,
            month = month.value,
        )
    }
}

/**
 * Updates a category.
 * @param category The category to be updated.
 */
internal fun CategoriesQueries.update(category: Category) {
    updateCategory(
        id = category.id.value,
        name = category.name,
        amount = category.amount.cents,
    )
}

/**
 * Deletes a category.
 * @param category The category to be deleted.
 */
internal fun CategoriesQueries.delete(
    category: Category,
) {
    deleteCategory(category.id.value)
}

/**
 * Deletes a recurrence in a specific position in the recurrence list of a category.
 * It can be used to remove a day in a month for a monthly recurrence, for example.
 * @param category The category to have the recurrence removed.
 * @param recurrenceIndex The index of the recurrence to be removed.
 */
internal fun CategoriesQueries.deleteRecurrence(
    category: Category,
    recurrenceIndex: Int,
) {
    // since the seasonal recurrence is a combination of day and month, it's necessary two ints to ensure that all types
    // of recurrences can be deleted.
    // for fixed and variable recurrences, the second parameter is always 0, which is a dummy value that will not be
    // used.
    val (p1: Int, p2: Int) = when (val recurrences = category.recurrences) {
        is Recurrences.Fixed -> recurrences.daysOfMonth[recurrenceIndex].value to 0
        is Recurrences.Variable -> recurrences.daysOfWeek[recurrenceIndex].value to 0
        is Recurrences.Seasonal -> {
            val dayAndMonth = recurrences.daysAndMonths[recurrenceIndex]
            dayAndMonth.day.value to dayAndMonth.month.value
        }
    }
    deleteRecurrence(
        id = category.id.value,
        p1 = p1,
        p2 = p2,
    )
}
